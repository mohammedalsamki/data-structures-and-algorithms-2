# Merge Sort

<!-- Description of the challenge -->

A method takes an array as arugment and depending on slicing and midpoint it
will return a sorted array.

## Approach & Efficiency

<!-- What approach did you take? Discuss Why. What is the Big O space/time for this approach? -->

Time :  O(N*log N)
Space : O(N)

Because of sclicing reduce the the time complixity 50 times than the normal way we used in insertion sort code

## Blog : [Link](BLOG.md)

## Implementation

* [x] Provide a visual step through for each of the sample arrays based on the provided pseudo code
* [x] Convert the pseudo-code into working code in your language
* [x] Present a complete set of working tests

## Requirements

* [x] Write unit tests

## Test Requirements

* [x] Test The method by these samples:
    - [x] Reverse-sorted: [20, 18, 12, 8, 5, -2]
    - [x] Few uniques: [5, 12, 7, 5, 5, 7]
    - [x] Nearly-sorted: [2, 3, 5, 7, 13, 11]
# White Board

![Merg_Sort](/python/merge_sort/merge_sort.png)

## Collaboration

I collabrated with **Faisal Kushha** in Miro and code translating
